<!DOCTYPE html>
<html>
<head>
	<title>Panel Tests</title>
</head>
<meta charset="UTF-8">
<style>
		body {
			background-color: black;
			 min-height: 100%;
		}

		html{height: 100%;}

</style>
<body>
	<script type="text/javascript">

//Initialize variables

		const BACKGROUND_LAYER = 0;
		const MAIN_LAYER = 1;
		const GRID_LAYER = 2;
		var panelIndex = [];
	
		var zoomLevel = 1;
		var pixelSize = 4;

		var mouseTarget = null;
		var initClickX = 0;
		var	initClickY = 0;
		var isHeldClick = false;

		//DEBUG TOOLS		
			var stop = false;
			var frameCount = 0;
			var now = performance.now();
			//var debugMode = false;
			//var rebindMode = false;
			var deltaFr = 0;
			var deltaTime = performance.now();
			var frameBefore = 0;


		var grid = new Image();
		grid.src = "images/GridRedo.png";
		grid.addEventListener("load", loadAssets, false)

		var tak = new Image();
		tak.src = "images/TakuyaIdle2.png"

		var body = document.getElementsByTagName("body")[0];
		body.width = window.outerWidth;
		body.height = window.outerHeight;
		body.addEventListener("mouseleave", mouseLeaveHandler, false);
		body.addEventListener("mousemove", mouseMoveHandler, false);


//
		

	function start(){
		now = performance.now();

		if (now - deltaTime > 1000) {
			deltaFr = frameCount - frameBefore;
			frameBefore = frameCount;
			deltaTime = now;
		}

		if (!stop){					
			frameCount++;
			requestAnimationFrame(start);
		}
	}


// Panel related functions

	function Panel (id, width, height, spawnX = 0, spawnY = 0) {
		this.pack = []

		width = width - (width % (pixelSize * zoomLevel));
		height = height - (height % (pixelSize * zoomLevel));

		for (let p = 0; p < 3; p++){
			let tempPan  = document.createElement("canvas");			
			tempPan.width = scalePx(width);
			tempPan.height = scalePx(height);
			tempPan.xPos = spawnX;
			tempPan.yPos = spawnY;

			tempPan.style.position = "absolute";
			tempPan.style.zIndex = `${p}`
			tempPan.style.margin = tempPan.yPos + "px 0px 0px " + tempPan.xPos + "px";
			tempPan.getContext("2d").imageSmoothingEnabled = false;

			this.pack.push(tempPan);
		}		
		drawBackground(this.pack[BACKGROUND_LAYER]);
		drawGrid(this.pack[GRID_LAYER]);
		addToPlay(this.pack);
	}


	function addToPlay (panPack) {
		let topPanel = panPack.length - 1;

		panPack[topPanel].addEventListener("mouseup", mouseUpHandler, false);
		panPack[topPanel].addEventListener("mousedown", mouseDownHandler, false);
		panPack[topPanel].addEventListener("mousemove", mouseMoveHandler, false);
		panPack[topPanel].addEventListener("contextmenu", function (e) { e.preventDefault();}, false);

		panPack[topPanel].id = panelIndex.length;
		panelIndex.push(panPack);

		for (let pan in panPack) {
			body.appendChild(panPack[pan]);
		}
	}

	function Widget(
		srcCanvas, 
		sprite, 
		purpose,
		width, height,
		hitWidth, hitHeight, 		 
		onDown = -1, onUp = -1, onHold = -1, onHover = -1, onLeave = -1) {
			this.sprite = sprite;
			this.width = width;
			this.height = height;
			this.purpose = purpose;
	}

		
// Screen drawing functions

	function scalePx(num) {
		return (num * zoomLevel);
	}


	function drawGrid(srcCanvas) {	
		// Not using Math.ceil() here because it's too expensive. 
		// Using cheaper hacks instead by abusing how negative numbers are rounded.
		// ~ is a bitwise NOT, which always makes a number negative.
		// Then multiply by -1 to cencel out the negative.
		for (let w = 0; w < ~(srcCanvas.width / grid.width) * -1; w++) {			
			for(let h = 0; h < ~(srcCanvas.height / grid.height) * -1; h++) {
 				scaleImg(
					srcCanvas.getContext("2d"),					
					grid, 
					grid.width * w, 
					grid.height * h 
				);
			}
		}
	}


	function drawBackground(srcCanvas) {
		scaleRect(srcCanvas, 0, 0, srcCanvas.width, srcCanvas.height);
	}


	function changeScale(srcCanvas, scale){
		zoomLevel = scale;

		srcCanvas.width = srcCanvas.width * zoomLevel;
		srcCanvas.height = srcCanvas.height * zoomLevel;
	}


	function scaleRect(cv, rectX, rectY, rectWid, rectHgt) {
		cv = cv.getContext("2d");			
		cv.fillStyle = "#78a262";
		cv.fillRect(scalePx(rectX), scalePx(rectY), scalePx(rectWid), scalePx(rectHgt));
	}


	function scaleImg(destCtx, spr, sprX, sprY, clipWidth, clipHeight, clipX, clipY){
		if (arguments.length == 4) {
			destCtx.drawImage(
				spr, 
				scalePx(sprX), 
				scalePx(sprY), 
				scalePx(spr.width), 
				scalePx(spr.height)
			);
		}
		else if (arguments.length == 8) {
			destCtx.drawImage(
				spr,
				clipX,
				clipY,
				clipWidth,
				clipHeight,
				scalePx(sprX),
				scalePx(sprY),
				scalePx(clipWidth),
				scalePx(clipHeight)
			);
		}
		else {
			console.log("UNEXPECTED # of arguments in scaleImg().");
		}
	}

//
// Event Handling

	function loadAssets(){
		//stop = false;
		var yup = new Panel("initial", 360, 210);
		start();
	}


	function mouseDownHandler(event) {
		mouseTarget = event.currentTarget;

		if (event.which == 3) {
			isHeldClick = true;
		}
		initClickX = event.offsetX;
		initClickY = event.offsetY;
	}

	function mouseMoveHandler(event){
		if (isHeldClick && mouseTarget.nodeName == "CANVAS") {
			let stack = panelIndex[mouseTarget.id]

			for (let pn in stack) {
				stack[pn].style.margin = (event.clientY - initClickY) + "px 0px 0px "+ (event.clientX - initClickX) + "px";
			}
		}
	}


	function mouseEnterHandler() {

	}


	function mouseLeaveHandler() {
		mouseUpHandler();
	}


	function mouseUpHandler() {
		mouseTarget = null;
		isHeldClick = false;
		initClickY = 0;
		initClickX = 0;
	}
	
//
	</script>
</body>
</html>