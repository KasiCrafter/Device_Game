<!doctype html>
<html>
	<head>
		<title>Device Testing</title>
		<meta charset="UTF-8">
		<style>
			body {
				background-color: black;
			}
			canvas {
				background: white;
			}
			#auxDisplay {
				position: absolute;
				top: 8px;
				left: 132px;
			}
			#theButton {
				cursor : pointer;
			}
			
		</style>
	</head>
	<body onload="gameLoop()">
		<canvas id="screenBack" width="120" height="140"></canvas>
		<canvas id="theButton" width="120" height="48"></canvas>
		<canvas id="auxDisplay" width="120" height="88"></canvas> <!-- height = 88   -->
		<div style="display:none;">
  			<img id="background" src="images/DtctrBckgrndBs.png" width="120" height="140">
			<img id="blackScreen" src="images/BlackScreen.png" width="120" height="140">
 			<img id="gridLayer" src="images/DtctrsLstLr.png" width="120" height="140">
 			<img id="fontOnWhite" src="images/TextOnWhite.png" width="120" height="140">
			<img id="fontOnBlack" src="images/TextOnBlack.png" width="120" height="140">	

  			<img id="idle" src="images/TrnsprntTktPxls.png" width="120" height="140">
  			<img id="idle2" src="images/TakuyaIdle2.png" width="120" height="140">
 			<img id="walking1" src="images/TakuyaWalk1.png" width="120" height="140">
			<img id="walking2" src="images/TakuyaWalk2.png" width="120" height="140">
			<img id="return" src="images/ReturnMenuIcon.png" width="120" height="100">
			<img id="strobe" src="images/StrobeMenuIcon.png" width="120" height="100">
			<img id="minigame" src="images/MinigameMenuIcon.png" width="120" height="100">
			<img id="unselectedSquare" src="images/UnselectedSquareMenuIcon.png" width="16" height="12">
			<img id="selectedSquare" src="images/SelectedSquareMenuIcon.png" width="16" height="12">
			<img id="unselectedX" src="images/UnselectedXMenuIcon.png" width="20" height="12">
			<img id="selectedX" src="images/SelectedXMenuIcon.png" width="20" height="12">

			<!-- <img id="itemGlow" src=> -->
			<img id="items" src="images/ItemsMenuIcon.png" width="120" height="100">
			<img id="herb1" src="images/Supply1Placeholder.png" width="120" height="100">
			<img id="rod1" src="images/Supply2Placeholder.png" width="120" height="100">
			<img id="wood1" src="images/Supply3Placeholder.png" width="120" height="100">
			<img id="shield1" src="images/Supply4Placeholder.png" width="120" height="100">
			<img id="tome1" src="images/Supply5Placeholder.png" width="120" height="100">

			<img id="theButtonIdle" src="images/TheButtonIdle.png" width="120" height="48">
			<img id="theButtonHover" src="images/TheButtonHover.png" width="120" height="48">
			<img id="theButtonClick" src="images/TheButtonClicked.png" width="120" height="48">
		</div>

		<script>
			var gameState = "idle";
			var gamePrev = "";
			var pixelSize = 4;
			var isTaskDone = false;

			var blah = document.getElementById("environment");

			var mainScreen = document.getElementById("screenBack");
			var ctxMain = mainScreen.getContext("2d");
			var pointerX = 0;
			var pointerY = 0;
			var image = document.getElementById("background");
			var image2 = document.getElementById("idle");
			var image3 = document.getElementById("gridLayer");
			var image4 = document.getElementById("idle2");
			var walk1 = document.getElementById("walking1");
			var walk2 = document.getElementById("walking2");
			var idleState = "idle";
			var idleCounter = 0;
			var currentIdle = image2;
			var flipImage = false;
			var backgroundColor = [];
			var invertImageData = [];
			var invertOn = false;
			
			var returnIcon = document.getElementById("return");
			var strobeIcon = document.getElementById("strobe");
			var minigameIcon = document.getElementById("minigame");
			var squareIcon1 = document.getElementById("unselectedSquare");
			var squareIcon2 = document.getElementById("selectedSquare");
			var xSelectIcon = document.getElementById("selectedX");
			var xUnselectIcon = document.getElementById("unselectedX");

			var animationQueue = [];
			var animationIsRecord = true;

			function AnimationObject (sprite, coordX, coordY, ctx, screen, miscData) {						
				/*	
					int,	  			X coord 
					int,				Y coord 
					ctxMain,    		context/cxt 
					mainScreen,  		screen 
					buttonJustClicked,  miscData 

					func name,  		function 
					milliseconds,		delay 
					int,				queue pos
					[false, millisecs],	do When 
					[0, millisecs], 	do Every
					[int1, int2...], 	do Chain 
					int, 				do Once  
				*/


				this.sprite = sprite;
				this.coordX = coordX;
				this.coordY = coordY;
				this.ctx = ctx;
				this.screen = screen;
				this.miscData = miscData;
				this.functionData = -1;
				this.argsCheck = 0;
				this.functionArray = [];

				
				if (arguments.length == 13) {
					this.argsCheck = 1;
				}
				else if (arguments.length == 20) {
					this.argsCheck = 2;
				}
				else if (arguments.length == 27) {
					this.argsCheck = 3;
				}
				else if (arguments.length == 34) {
					this.argsCheck = 4;
				}
				else if (arguments.length == 41) {
					this.argsCheck = 5;
				}
				else{
					this.argsCheck = -1;
				}

				for (anm = 6; anm < arguments.length - 6; anm += 7) {
					this.functionArray.push(
						{
							function : arguments[anm],
							delay : arguments[anm + 1],
							isDone: false,
							queuePos : arguments[anm + 2],
							timeLast : performance.now(),
							doWhen : arguments[anm + 3],
							doEvery : arguments[anm + 4],
							doChain : arguments[anm + 5],
							doOnce : arguments[anm + 6]
						}
					);
				}



				/* this.functionArray = [
					{
						function : f1,
						delay: d1,
						isDone : false,
						queuePos : q1,
						timeLast : performance.now(),
						doWhen : w1,
						doEvery : e1,
						doChain : c1,
						doOnce : o1
					},
					{
						function : f2,
						delay: d2,
						isDone : false,
						queuePos : q2,
						timeLast : performance.now(),
						doWhen : w2,
						doEvery : e2,
						doChain : c2,
						doOnce : o2
					},
					{
						function : f3,
						delay: d3,
						isDone : false,
						queuePos : q3,
						timeLast : performance.now(),
						doWhen : w3,
						doEvery : e3,
						doChain : c3,
						doOnce : o3
					},
					{
						function : f4,
						delay: d4,
						isDone : false,
						queuePos : q4,
						timeLast : performance.now(),
						doWhen : w4,
						doEvery : e4,
						doChain : c4,
						doOnce : o4
					},
					{
						function : f5,
						delay: d5,
						isDone : false,
						queuePos : q5,
						timeLast : performance.now(),
						doWhen : w5,
						doEvery : e5,
						doChain : c5,
						doOnce : o5
					},
					{
						function : f6,
						delay: d6,
						isDone : false,
						queuePos : q6,
						timeLast : performance.now(),
						doWhen : w6,
						doEvery : e6,
						doChain : c6,
						doOnce : o6
					}
				];

				if (f2 == undefined) {
					this.functionArray[1].isDone = true;
				}

				if (f3 == undefined) {
					this.functionArray[2].isDone = true;
				}

				if (f4 == undefined) {
					this.functionArray[3].isDone = true;
				}

				if (f5 == undefined) {
					this.functionArray[4].isDone = true;
				}

				if (f6 == undefined) {
					this.functionArray[5].isDone = true;
				} */
			}

			var listPointer = 0;
			var listAnchor = "";
			var listDoRun = false;
			var listTextColor = textOnWhite;
			var listArray = [];
			var listDisplayCount = 0;

			var menuPipGenerate = true;
			var menuPointer = 0;
			var menuAnchor = 0;
			var menuPips = 0;
			var menuMiddle = 0;
			var menuCurrentPip = 0;
			var menuPipImage = squareIcon1;
			var menuPipIndent = 0;
			var menuPipTimeBefore = 0;
			var menuPipTimeNow = 0;
			var menuPipRate = 300;
			var menuIndexStack = [];

			var menuItems = [
				{	
					title : "RETURN",
					sprite : returnIcon,
					description : "HOLD BUTTON TO EXIT MENU.",
					referNext : 0,
					referEnter : menuReturn,
					isDisplayed : true
				},
				{	
					title : "GAMES",
					sprite : minigameIcon,
					description : "PLAY TO LOWER THE STEP COUNT.",
					referNext : 3,
					referEnter : 2,
					isDisplayed : true
				},
				{	
					title : "STROBE",
					sprite : strobeIcon,
					description : "TEST FOR SCREEN REFRESH RATE.",
					referNext : 0,
					referEnter : strobeGame,
					isDisplayed : true
				},
				{	
					title : "ITEMS",
					sprite : items,
					description : "MANAGE AND USE ALL YOUR GEAR.",
					referNext : 0,
					referEnter : 4,
					isDisplayed : true
				},
				{	
					title : "LOOT",
					sprite : minigameIcon,
					description : "EXAMINE YOUR ITEMS.",
					referNext : 5,
					referEnter : drawItems,
					isDisplayed : true
				},
				{	
					title : "CRAFT",
					sprite : strobeIcon,
					description : "REFINE AND MAKE NEW LOOT.",
					referNext : 0,
					referEnter : drawCrafting,
					isDisplayed : true
				},
				{	
					title : "STROBE 6",
					sprite : strobeIcon,
					description : "TEST FOR SCREEN REFRESH RATE.",
					referNext : 0,
					referEnter : 0,
					isDisplayed : true
				}
			];

			var monsterPointer = 0;
			var monsterBlink = 0;

			var monsterStatTable = [
				{
					species : "",
					nickname : "",
					sprite : "",

					level : 0,
					hearts : 0,
					maxHealth: 0,
					currentHealth : 0,
					guts : 0,
					wits : 0,
					skill : 0,
					speed : 0,
					geswoleLimit : 0,
					moveList : [],
					knownMoves : [],
					moveCooldown : 0,
					currentRelic: {},

					miniGuts : 0,
					miniWits : 0,
					miniSkill : 0,
					mood : "",

					affection : 0,
					distanceWalked : 0,

					borrowedPower : [],
					fruitPower : []
				}
			];

			var monsterTeam = [
				{
					species : "TEST",
					nickname : "ICY",
					sprite : "",

					level : 1,
					hearts : 3,
					maxHealth: 20,
					currentHealth : 10,
					guts : 0,
					wits : 0,
					skill : 0,
					speed : 0,
					geswoleLimit : 0,
					moveList : [],
					knownMoves : [],
					moveCooldown : 0,
					currentRelic: {},

					miniGuts : 0,
					miniWits : 0,
					miniSkill : 0,

					affection : 0,
					distanceWalked : 0,

					borrowedPower : [],
					fruitPower : []
				}
			];

			var monsterStorage = [];


			function ItemObject(name, quantity, sprite, description, type, effectArray, isFindable, isCraftable, recipieArray) {
				this.name = name;
				this.quantity = quantity;
				this.sprite = sprite;
				this.description = description;
				this.type = type;
				this.effectArray = effectArray;
				this.isFindable = isFindable;
				this.isCraftable = isCraftable;
				this.recipieArray = recipieArray;
			}

			var inventory = [
				new ItemObject("REPLICATE", "?", herb1, "HOLD BUTTON FOR DUPE.", "dev",[testAdd]),
				new ItemObject("    EXIT       EXIT       EXIT       EXIT   ","X", herb1,"HOLD BUTTON TO EXIT MENU.", "dev",[])			
			];
			var invPos = 0;
			var invPosHolder = 0;
			var invRecipiePos = 0;
			var invTarget = 0;
			var invTextRaw = "";
			var invArrayFocus = [];
			var invArrayHolder = [];
			var invNumberToUse = 1;		
			var invIsNumChosen = false;
			var invBlinkTime = 300;
			var invBlinkBefore = 0;


			var itemTable = [
				new ItemObject(
					"PLAIN HERB", 
					0, 
					herb1, 
					"HAS MEDICAL USES.",
					"resource",
					[],
					true,
					false					
				),
				new ItemObject(
					"LOG BUNDLE", 
					0, 
					wood1, 
					"GOOD FOR FUEL.",
					"resource",
					[],
					true,
					false					
				),
				new ItemObject(
					"REVERB ROB", 
					0, 
					rod1, 
					"WHEN EQUIPED, ALLOWS INSTANT REACT.",
					"relic",
					[],
					false,
					true,
					[0,3,1,3]
				),
				new ItemObject(
					"RICKETY SHIELD", 
					0, 
					shield1, 
					"USE ONE CHARGE TO HALF ENEMY ATTACK DAMAGE.",
					"relic",
					[],
					false,
					true,
					[1,3]
				),
				new ItemObject(
					"HEALING TOME", 
					0, 
					tome1, 
					"USE TO DO A DECENT HEAL ON THE CHOSEN MONSTER.",
					"relic",
					[],
					false,
					true,
					[0,3]
				),
				new ItemObject(
					"    EXIT       EXIT       EXIT       EXIT   ",
					"X", 
					herb1,
					"HOLD BUTTON TO EXIT MENU.", 
					"dev",
					[],
					false,
					true,
					[-1,1]
				),
			];


			var subFunctionInitialized = false;
			var coinReward = 0;

			var strobeRate = Infinity;
			var strobeFirstClick = 0;
			var strobeDeltaClick = true;
			

			var auxScreen = document.getElementById("auxDisplay");
			var ctxAux = auxScreen.getContext("2d");
			var blackBackground = document.getElementById("blackScreen");
			var textOnWhite = document.getElementById("fontOnWhite");
			var textOnBlack = document.getElementById("fontOnBlack");			
			var coinsCurrent = 0;
			var coinsTotal = 0;
			var coinsToSubtract = 0;
			var coinsSubtracting = 0;
			var coinsSubtractingUpdate = 100;
			var coinsSubtractingIncrement = 1;
			var coinsSubtractingTimeBefore = 0;
			var coinsSubtratcingTimeNow = 0;
			var coinsClickPower = 1;
			var coinsPassiveClick = 0;
			var coinsPassivePower = 1;
			var coinsPassiveActive = false;
			var coinsPassiveCounterBefore = performance.now();
			var coinsPassiveCounterNow = 0;


			var textAux = "";
			var textQueue = [];
			var textIgnoreReset = false;
			function TextMeta(id) {
				this.id = id;
				this.textTimeLast = performance.now();
				this.textIsCrawl = false;
				this.textMaxCrawl = 0;
				this.textVisableCrawl = 0;
				this.textCrawlPosition = 0;
				this.textCrawlCount = 1;
			}
			var textTimeNow = 0;
			var textTimeCount = 0;
			var textStartCrawl = 1500;
			var textNextCrawl = 100;
			var textScrollSpeed = 4;
			var textSyncMaxCrawl = 0;
			var textWidth = 16;
			var textHeight = 24;
			var textParser = [
				{character : " ", sheetRow : 7, sheetColumn : 0, widthModify : -8},
				{character : "~", sheetRow : 7, sheetColumn : 0, widthModify : -12},
				{character : ".", sheetRow : 1, sheetColumn : 5, widthModify : -8},
				{character : "_", sheetRow : 0, sheetColumn : 6, widthModify : -4},
				{character : ";", sheetRow : 1, sheetColumn : 6, widthModify : -12},
				{character : "|", sheetRow : 2, sheetColumn : 6, widthModify : -12},
				{character : "#", sheetRow : 3, sheetColumn : 8, widthModify : 0},
				{character : "E", sheetRow : 4, sheetColumn : 0, widthModify : 0},
				{character : "T", sheetRow : 5, sheetColumn : 2, widthModify : 0},
				{character : "1", sheetRow : 5, sheetColumn : 3, widthModify : 0},
				{character : "2", sheetRow : 6, sheetColumn : 3, widthModify : 0},
				{character : "3", sheetRow : 0, sheetColumn : 4, widthModify : 0},
				{character : "4", sheetRow : 1, sheetColumn : 4, widthModify : 0},
				{character : "5", sheetRow : 2, sheetColumn : 4, widthModify : 0},
				{character : "6", sheetRow : 3, sheetColumn : 4, widthModify : 0},
				{character : "7", sheetRow : 4, sheetColumn : 4, widthModify : 0},
				{character : "8", sheetRow : 5, sheetColumn : 4, widthModify : 0},
				{character : "9", sheetRow : 6, sheetColumn : 4, widthModify : 0},
				{character : "0", sheetRow : 0, sheetColumn : 5, widthModify : 0},
				{character : "A", sheetRow : 0, sheetColumn : 0, widthModify : 0},
				{character : "O", sheetRow : 0, sheetColumn : 2, widthModify : 0},
				{character : "I", sheetRow : 1, sheetColumn : 1, widthModify : 0},
				{character : "N", sheetRow : 6, sheetColumn : 1, widthModify : 0},
				{character : "S", sheetRow : 4, sheetColumn : 2, widthModify : 0},
				{character : "H", sheetRow : 0, sheetColumn : 1, widthModify : 0},
				{character : "R", sheetRow : 3, sheetColumn : 2, widthModify : 0},
				{character : "D", sheetRow : 3, sheetColumn : 0, widthModify : 0},
				{character : "L", sheetRow : 4, sheetColumn : 1, widthModify : 0},
				{character : "C", sheetRow : 2, sheetColumn : 0, widthModify : 0},
				{character : "U", sheetRow : 6, sheetColumn : 2, widthModify : 0},
				{character : "M", sheetRow : 5, sheetColumn : 1, widthModify : 0},
				{character : "W", sheetRow : 1, sheetColumn : 3, widthModify : 0},
				{character : "F", sheetRow : 5, sheetColumn : 0, widthModify : 0},
				{character : "G", sheetRow : 6, sheetColumn : 0, widthModify : 0},
				{character : "Y", sheetRow : 3, sheetColumn : 3, widthModify : 0},
				{character : "P", sheetRow : 1, sheetColumn : 2, widthModify : 0},
				{character : "B", sheetRow : 1, sheetColumn : 0, widthModify : 0},
				{character : "V", sheetRow : 0, sheetColumn : 3, widthModify : 0},
				{character : "K", sheetRow : 3, sheetColumn : 1, widthModify : 0},
				{character : "J", sheetRow : 2, sheetColumn : 1, widthModify : 0},
				{character : "X", sheetRow : 2, sheetColumn : 3, widthModify : 0},
				{character : "Q", sheetRow : 2, sheetColumn : 2, widthModify : 0},
				{character : "Z", sheetRow : 4, sheetColumn : 3, widthModify : 0},
				{character : "?", sheetRow : 2, sheetColumn : 5, widthModify : 0},
				{character : "!", sheetRow : 3, sheetColumn : 5, widthModify : 0},
				{character : "(", sheetRow : 4, sheetColumn : 5, widthModify : -4},
				{character : ")", sheetRow : 5, sheetColumn : 5, widthModify : -4},
				{character : ",", sheetRow : 6, sheetColumn : 5, widthModify : -4},
				{character : "[", sheetRow : 3, sheetColumn : 6, widthModify : -4},
				{character : "]", sheetRow : 4, sheetColumn : 6, widthModify : -4},
				{character : "-", sheetRow : 5, sheetColumn : 6, widthModify : -4},
				{character : ":", sheetRow : 6, sheetColumn : 6, widthModify : -8},
				{character : "+", sheetRow : 0, sheetColumn : 7, widthModify : 0},
				{character : "=", sheetRow : 1, sheetColumn : 7, widthModify : 0},
				{character : "<", sheetRow : 2, sheetColumn : 7, widthModify : 0},
				{character : ">", sheetRow : 3, sheetColumn : 7, widthModify : 0},
				{character : "*", sheetRow : 4, sheetColumn : 7, widthModify : 0},
				{character : "/", sheetRow : 5, sheetColumn : 7, widthModify : 0},
				{character : "\\", sheetRow : 6, sheetColumn : 7, widthModify : 0},
				{character : "%", sheetRow : 0, sheetColumn : 8, widthModify : 0},
				{character : "^", sheetRow : 1, sheetColumn : 8, widthModify : 0},
				{character : "'", sheetRow : 2, sheetColumn : 8, widthModify : 0}
			];
			

			var theButtonScreen = document.getElementById("theButton");
			var ctxButton = theButtonScreen.getContext("2d");
			var buttonIdle = document.getElementById("theButtonIdle");
			var buttonHover = document.getElementById("theButtonHover");
			var buttonClick = document.getElementById("theButtonClick");
			var isButtonClick = false;
			var isButtonHeld = false;
			var isButtonHover = false;
			var isButtonFlick = false;
			var buttonBlocked = false;
			var buttonHoldPending = false;
			var buttonIgnoreClick = false;
			var buttonProxyHeld = false;
			var timeStartClick = -1;
			var timeLastClick = -1;
			var timeHeldDown = 0;
			var timeUnpressed = -1;
			var buttonJustClicked = false;
			var timeForHold = 500;
			var timeForDrop = 1700;
			var buttonImage = buttonIdle;

			theButtonScreen.addEventListener("mouseenter", mouseEnterHandler, false);
			theButtonScreen.addEventListener("mouseleave", mouseLeaveHandler, false);
			theButtonScreen.addEventListener("mouseup", mouseUpHandler, false);
			document.addEventListener("mouseup", mouseUpHandler, false);
			theButtonScreen.addEventListener("mousedown", mouseDownHandler, false);


		/* Universal screen functions */

			function gameLoop() {

				updateMenu();
				updateText();

			/* Main screen draws */

				ctxMain.clearRect(0,0, mainScreen.width, mainScreen.height);
				drawBackground(ctxMain); 			

				ctxAux.clearRect(0, 0, auxScreen.width, auxScreen.height);
				drawBackground(ctxAux);	

				if (gameState == "idle") {
					drawIdle();
				}
				else if (gameState == "menu") {
					drawMenu();
				}
				/* else if (gameState == "subFunction" || gameState == "inventory") {
					menuItems[menuPointer].referEnter();
				} */
				else {
					menuItems[menuPointer].referEnter();
				}

			/* Aux screen draws */

				if (gameState == "idle") {
					updateCoins();
					drawCoins();
				}
				else if (gameState == "menu") {
					drawAux();
				}
				else if (gameState == "subFunction") {
					drawAux();
				}
				else if (gameState == "inventory"){
					drawAux();
				}							

			/* Post-process updates and draws */

				drawGrid(ctxAux);

				animationParser();

				drawGrid(ctxMain);

			/* Button draws */

				buttonUpdate(); 
				drawButton();

			/* Looping function */

				requestAnimationFrame(gameLoop);	
			}



			function animationParser() {	
				if (animationQueue.length > 0){
					animationIsRecord = false;
				}		   
				for (a = 0; a < animationQueue.length; a++) {
						for (p = 0; p < animationQueue[a].functionArray.length; p++) {
							for (f = 0; f < animationQueue[a].functionArray.length; f++) {
								if (animationQueue[a].functionArray[f].queuePos == p) {
									if (animationQueue[a].functionArray[f].isDone == false && performance.now() - animationQueue[a].functionArray[f].timeLast >= animationQueue[a].functionArray[f].delay) {
										animationQueue[a].functionArray[f].delay = 0;
										if (eval(animationQueue[a].functionArray[f].doWhen[0]) == true) {
											animationQueue[a].functionArray[f].function(
												animationQueue[a].ctx, 
												animationQueue[a].screen, 
												animationQueue[a].sprite, 
												animationQueue[a].coordX, 
												animationQueue[a].coordY, 
												animationQueue[a].functionData
											);

							  			  animationQueue[a].functionArray[f].timeLast = performance.now();
										}
  								   		else if (performance.now() - animationQueue[a].functionArray[f].timeLast >= eval(animationQueue[a].functionArray[f].doEvery[0]) && eval(animationQueue[a].functionArray[f].doEvery[0]) > -1) {
											animationQueue[a].functionArray[f].function(
												animationQueue[a].ctx, 
												animationQueue[a].screen, 
												animationQueue[a].sprite, 
												animationQueue[a].coordX, 
												animationQueue[a].coordY, 
												animationQueue[a].functionData
									 	   );

											animationQueue[a].functionArray[f].doEvery[1] -= animationQueue[a].functionArray[f].doEvery[0];

											if (animationQueue[a].functionArray[f].doEvery[1] < 0) {
												animationQueue[a].functionArray[f].doEvery[0] = -1;
											}

											animationQueue[a].functionArray[f].timeLast = performance.now();
										}
										else if (animationQueue[a].functionArray[f].doChain.length > 0 && performance.now() - animationQueue[a].functionArray[f].timeLast >= eval(animationQueue[a].functionArray[f].doChain[0])) {
										animationQueue[a].functionArray[f].function(
											animationQueue[a].ctx, 
											animationQueue[a].screen, 
											animationQueue[a].sprite, 
											animationQueue[a].coordX, 
											animationQueue[a].coordY, 
											animationQueue[a].functionData
										);

 										animationQueue[a].functionArray[f].doChain.shift();
										animationQueue[a].functionArray[f].timeLast = performance.now();
										}
										else if (performance.now() - animationQueue[a].functionArray[f].timeLast >=	eval(animationQueue[a].functionArray[f].doOnce) && eval(animationQueue[a].functionArray[f].doOnce) != -1){
										animationQueue[a].functionArray[f].function(
											animationQueue[a].ctx, 
											animationQueue[a].screen, 
											animationQueue[a].sprite, 
											animationQueue[a].coordX, 
											animationQueue[a].coordY, 
											animationQueue[a].functionData
										);

										animationQueue[a].functionArray[f].doOnce = -1;
										animationQueue[a].functionArray[f].timeLast = performance.now();
										}
										else {
											if(performance.now() -  animationQueue[a].functionArray[f].timeLast >= eval(animationQueue[a].functionArray[f].doWhen[1])) {
												animationQueue[a].functionArray[f].isDone = true;
											}
										}
									}
								}
							}
						}
				}
			}

			function animateNextFrame(ctx, screen, sprite, coordX, coordY, spriteArray) {
				for (frm = 0; frm < spriteArray.length; frm++) {
					if (spriteArray[frm] == sprite) {
						animationQueue[a].sprite = spriteArray[frm + 1];
						break;
					}
				}
			}

			function animateTranslate(ctx, screen, sprite, coordX, coordY, deltaXYArray){
				this.coordX = coordX;
				this.coordY = coordY;

				return([(this.coordX + deltaXYArray[0]), (this.coordY + deltaXYArray[1])]);
			}

			function drawBackground (context) {
				context.drawImage(image, 0, 0);

				if (invertOn == false) {
					backgroundColor = context.getImageData(0, 0, 1, 1);
				}
			}

			function drawBlack(context) {
				context.drawImage(blackBackground, 0, 0);
			}

			function drawGrid(context) {
				context.drawImage(image3, 0, 0);
			}

			function drawText(transcribe, textType, alignType, context, screen, addX, addY, id) {
				transcribe = transcribe.toUpperCase();
				transcribe = transcribe.split("");

				pointerX = addX;
				pointerY = addY;
				var trackerCount = 0;

				var lineLength = 0;
				var characterWidth = 0;
				var wordLength = 0;
				var prevSpaceIndex = 0;
				var breakTracker = [];
				var maxLength =  screen.width;
				


				for (q = 0; q < textQueue.length; q++) {
					if (id == textQueue[q].id) {
						break;
					}
				}

				if (q == textQueue.length) {
					textQueue.push(new TextMeta(id));
				}

				if (context == ctxMain) {
					textQueue[q].textVisableCrawl = mainScreen.width; 
				}
				else if (context == ctxAux) {
					textQueue[q].textVisableCrawl = auxScreen.height;
				}

				if (screen == auxScreen){
					textStartCrawl = 1500;
					textNextCrawl = 100;
					textScrollSpeed = 4;
				}
				else if (screen == mainScreen){
					textStartCrawl = 1000;
					textNextCrawl = 100;
					textScrollSpeed = 4;
				}


				for (tldr = 0; tldr < transcribe.length; tldr++) {
					if (transcribe[tldr] == " " || transcribe[tldr] == "." || transcribe[tldr] == "," || transcribe[tldr] == ";"|| transcribe[tldr] == ":" || transcribe[tldr] == "'") {
						characterWidth = 8;
						
						if ((transcribe[tldr] == " " || transcribe[tldr + 1]) && screen == auxScreen) {  
					/*skip this step for text on main screen */
							wordLength = 0;

							prevSpaceIndex = tldr;
						}
					}
					else if(transcribe[tldr] == "~" || transcribe[tldr] == "|") {
						characterWidth = 4;
					}

					else if (transcribe[tldr] == "(" || transcribe[tldr] == ")" || transcribe[tldr] == "[" || transcribe[tldr] == "]"
					|| transcribe[tldr] == "-" || transcribe[tldr] == "," || transcribe[tldr] == "_") {
						characterWidth = 12;
					}
					else {
						characterWidth = 16;
					}

					if (lineLength + characterWidth > maxLength && (screen == auxScreen || alignType == "center")) {  
						if (wordLength + characterWidth < maxLength) {  
							breakTracker.push(prevSpaceIndex);
						
							if (lineLength <= maxLength) {
								wordLength += characterWidth;
							}
		
							lineLength = wordLength;
						}
						else {
							transcribe.splice(0, transcribe.length, "T", "L", "D", "R");
							breakTracker.splice(0, breakTracker.length);
							tldr += 5;
						}						
					}						
					else if (screen == auxScreen) {
						if (transcribe[tldr] != " ") { 
							wordLength += characterWidth;
							}

						lineLength += characterWidth;
					}
					else if (screen == mainScreen) {
						lineLength += characterWidth;
					}
				}
				if (alignType == "normal") {
					if (screen == auxScreen) {
						textQueue[q].textMaxCrawl = (breakTracker.length + 1) * textHeight + addY - 
						textQueue[q].textVisableCrawl;
					}
					else if (screen == mainScreen) {					
						textQueue[q].textMaxCrawl = lineLength + addX - textQueue[q].textVisableCrawl;

						/* if (textSyncMaxCrawl < textQueue[q].textMaxCrawl) {
							textSyncMaxCrawl = textQueue[q].textMaxCrawl;
						}
						else if (textSyncMaxCrawl > textQueue[q].textMaxCrawl) {
							textQueue[q].textMaxCrawl = textSyncMaxCrawl;
						} */
					}				


					textTimeNow = performance.now();
					textTimeCount = textTimeNow - textQueue[q].textTimeLast;

					if (textTimeCount >= textStartCrawl && textQueue[q].textIsCrawl == false && 
					textQueue[q].textCrawlPosition == 0 && (breakTracker.length + 1 > (screen.height / textHeight) || 
					(screen == mainScreen && lineLength > maxLength))){
						textQueue[q].textIsCrawl = true;
					}			
					else if (textQueue[q].textCrawlPosition >= textQueue[q].textMaxCrawl && textTimeCount >= textStartCrawl) {
						textQueue[q].textTimeLast = performance.now();

						textQueue[q].textCrawlCount = 0;
						textQueue[q].textCrawlPosition = 0;
					}

					if (textQueue[q].textIsCrawl == true && textTimeCount >= textNextCrawl) {
						textQueue[q].textTimeLast = performance.now();

						textQueue[q].textCrawlCount++;
						textQueue[q].textCrawlPosition = textQueue[q].textCrawlCount * textScrollSpeed;

						if (textQueue[q].textCrawlPosition >= textQueue[q].textMaxCrawl) {
							textQueue[q].textIsCrawl = false;
						}
					}

					if (screen == mainScreen){
						pointerX = -textQueue[q].textCrawlPosition + addX;
					}
				}
				else if (alignType == "center") {
					var centerPos = (screen.width - lineLength + pixelSize) / 2;

					if ((centerPos / 2) % 2 != 0) {
						for (ctr = 0; ctr < transcribe.length; ctr++) {
							centerPos = Math.floor(centerPos);

							if (transcribe[ctr] == " ") {
								transcribe.splice(ctr, 0, "~");

								ctr++;

								if (textType == textOnBlack) {
									transcribe.push("~");
								}
								
							}

							/* if (ctr == transcribe.length - 1 && transcribe[ctr] != " ") {
								transcribe.splice(0, 0, "~");

								ctr++;
							} */
						}
					}

					while (centerPos > 0) {
						if (centerPos >= textWidth + textParser[0].widthModify) {
							transcribe.splice(0, 0, " ");

							if (textType == textOnBlack) {
								transcribe.push(" ");
							}

							centerPos -= textWidth + textParser[0].widthModify;
						}
						else if (centerPos >= textWidth + textParser[1].widthModify) {
							transcribe.splice(0, 0, "~");

							if (textType == textOnBlack) {
								transcribe.push("~");
							}

							centerPos -= textWidth + textParser[1].widthModify;
						}

						else {
							break;
						}
					}
				}

				for (i = 0; i < transcribe.length; i++) {				
					for (c = 0; c < textParser.length; c++) {
						if (screen == auxScreen) {
							if (i < breakTracker[0]) {  
							/* Add a completely different sequence for main screen prints */
								pointerY = -textQueue[q].textCrawlPosition + addY;
							}

							if (i >= breakTracker[trackerCount]) {
								pointerX = addX;
								pointerY = textHeight * (trackerCount + 1) + addY - textQueue[q].textCrawlPosition;

								trackerCount += 1;
							}
							else if (pointerY < textQueue[q].textVisableCrawl && pointerY >= -textHeight) {
								if (textParser[c].character == transcribe[i]) {
									context.drawImage(
										textType, 
										textParser[c].sheetRow * textWidth, 
										textParser[c].sheetColumn * textHeight, 
										textWidth + textParser[c].widthModify,
										textHeight + pixelSize, 
										pointerX, 
										pointerY - pixelSize, 
										textWidth + textParser[c].widthModify, 
										textHeight + pixelSize
									);
								
									pointerX += textWidth + textParser[c].widthModify;
								}
							}
						}
						else if (screen == mainScreen){
							if (pointerX < textQueue[q].textVisableCrawl) {
								if (textParser[c].character == transcribe[i]) {
									context.drawImage(
										textType, 
										textParser[c].sheetRow * textWidth,
										textParser[c].sheetColumn * textHeight, 
										textWidth + textParser[c].widthModify,
										textHeight + pixelSize, 
										pointerX, 
										pointerY - pixelSize, 
										textWidth + textParser[c].widthModify, 
										textHeight + pixelSize
									);
								
									pointerX += textWidth + textParser[c].widthModify;
								}
							}
						}
					}
				}
				pointerX = 0;
				pointerY = 0;
			}

			function flipHozDraw (context, screen, flippee) {
				var flippedX = -screen.width;

				animationQueue[a].functionData = 0;

				context.save();
				context.scale(-1, 1);
				context.drawImage(flippee, flippedX, 0);
				context.restore();
			}

			function invertColor (context, screen, sprite) {
				invertImageData = context.getImageData(0,0, screen.width, screen.height);

				for (i = 0; i < invertImageData.data.length; i += 4) {
					if (invertImageData.data[i] == 0 && invertImageData.data[i + 1] == 0 &&
					invertImageData.data[i + 2] == 0) {
						invertImageData.data[i] = backgroundColor.data[0];
						invertImageData.data[i + 1] = backgroundColor.data[1];
						invertImageData.data[i + 2] = backgroundColor.data[2];						
					}
					else if (invertImageData.data[i] == backgroundColor.data[0] &&
					invertImageData.data[i + 1] == backgroundColor.data[1] &&
					invertImageData.data[i + 2] == backgroundColor.data[2]) {
						invertImageData.data[i] = 0;
						invertImageData.data[i + 1] = 0;
						invertImageData.data[i + 2] = 0;
					}
				}

				if (invertOn == true) {
					invertOn = false;
				}
				else if (invertOn == false) {
					invertOn = true;
				}
			}

			function invertDraw (context, screen, sprite, offsetX, offsetY, funcData) {
				if (invertOn == true) {
					context.putImageData(invertImageData, 0, 0);
				}
			}

			function regDraw (context, screen, sprite, offsetX, offsetY, funcData) {
				if (funcData != 0) {
					context.drawImage(sprite, offsetX, offsetY);
				}
				
				if (funcData != 1) {
					animationQueue[a].functionData = -1;
				}
			}

			function updateText() {	
				if ((((buttonJustClicked == true || isButtonHeld == true) && isButtonHover == true) || isButtonFlick == true) && buttonBlocked == false && textIgnoreReset == false) {
					textQueue = [];
				}
			}
			
		/* Monster functions */

			function chooseMonster() {
				/* ctxMain.drawImage(
					monsterParty[monsterPointer].sprite, 
					0, 																	0, 
					0, 																	0, 
					0, 
					0, 
					monsterParty[monsterPointer].sprite.width, 
					monsterParty[monsterPointer].sprite.height
				); */				

				return(true);
			}

			function personalityGenerator(monsterStats, baseValues, mutator) {
				for (p = 0; p < baseValues.length; p++) {
					monsterStats[p] = baseValues[p] + floor(Math.random() * 10);
				}
			}

			function updatePersonality(monsterStats, personalityModify) {
				for (q = 0; q < personalityModify.length; q++) {
					monsterStats[q] += personalityModify[q];
				}
			}


		/* Inventory and Item functions */	

			function animateItemCraft() {
				if (animationIsRecord == true) {
					animationQueue.push(
						new AnimationObject(
								invArrayFocus[invPos].sprite,
								0,	  /* X coord */
								(mainScreen.height / 2) - invArrayFocus[invPos].sprite.height,	  /* Y coord  */
								ctxMain,  /*  context/cxt  */
								mainScreen,  /* screen */
								buttonJustClicked,   /* miscData */

								animateNextFrame,
								400,		   			/* delay  */
								0,	 					/* queue pos  */
								[false, Infinity],		/* do When  */
								[-1, Infinity],		 	/* do Every */
								[500, 1000,1500,2500,4500,6000, 6500],	   /*  do Chain */
								-1	 					/* do Once  */
							),

							new AnimationObject(
								invArrayFocus[invPos].sprite,
								0,	  /* X coord */
								0,	  /* Y coord  */
								ctxMain,  /*  context/cxt  */
								mainScreen,  /* screen */
								buttonJustClicked,   /* miscData */


								animateTranslate,
								0,             			/* delay */
								0,						/* queue pos */
								[false, Infinity],     	/* do When */
								[100, (screen.height / 2)],			/* do Every */
								[],						/* do Chain */
								-1						/* do Once */
							)
					);
				}
			} 

			function chooseNumToUse() {	
				if (buttonJustClicked == true && (invNumberToUse < invArrayFocus[invPos].quantity || invArrayFocus != inventory)) {
					invNumberToUse++;
				}
				else if (isButtonFlick == true && invNumberToUse > 0) {
					invNumberToUse--;
				}
				else if (buttonProxyHeld == true) {
					buttonProxyHeld = false;

					if (invNumberToUse == 0) {
						if (invArrayHolder.length == 0) {
							textMenuExit();
						}
						else {
							textMenuExit(true);
						}
					}
					else {
						invIsNumChosen = true;

						return(invNumberToUse);
					}
				}
				drawInvBlink();			
			}

			function drawInvBlink() {
				invTextRaw = "";

				if (performance.now() - invBlinkBefore >= invBlinkTime) {
					/* if (invNumberToUse <= 9 && invIsNumChosen == false) {
						invTextRaw += " ";
					} */

					if (invArrayFocus == inventory) {
						invTextRaw += "USE ";
					}
					else if (invArrayHolder.length == 0 && invIsNumChosen == false) {
						invTextRaw += "MAKE ";
					}
					/*
					else if (invIsNumChosen == true && invPos < invArrayFocus.length - 1){
						if (invArrayHolder[invPosHolder].recipieArray[(invPos * 2) + 1] * invNumberToUse <= 9 && ((findInInventory(invArrayHolder[invPosHolder].recipieArray[invPos * 2]) != inventory.length && inventory[findInInventory(invArrayHolder[invPosHolder].recipieArray[invPos * 2])].quantity <= 9) || findInInventory(invArrayHolder[invPosHolder].recipieArray[invPos * 2]) == inventory.length)) {
							invTextRaw = "   ~";
						}
						else if (invArrayHolder[invPosHolder].recipieArray[(invPos * 2) + 1] * invNumberToUse > 9 && findInInventory(invArrayHolder[invPosHolder].recipieArray[invPos * 2]) != inventory.length && inventory[findInInventory(invArrayHolder[invPosHolder].recipieArray[invPos * 2])].quantity > 9) {
							invTextRaw = "";
						}
						else if (invArrayHolder[invPosHolder].recipieArray[(invPos * 2) + 1] * invNumberToUse > 9 || (findInInventory(invArrayHolder[invPosHolder].recipieArray[invPos * 2]) != inventory.length && inventory[findInInventory(invArrayHolder[invPosHolder].recipieArray[invPos * 2])].quantity > 9)) {
							invTextRaw = "  ~";
						} 
					} */

					if (invIsNumChosen == false) {
						invTextRaw += "*" + invNumberToUse;
					}
					else if (invPos < invArrayFocus.length - 1) {
						invTextRaw += "*";

						if (findInInventory(invArrayHolder[invPosHolder].recipieArray[invPos * 2]) == inventory.length) {
							invTextRaw += "0";
						}
						else {
							invTextRaw += inventory[findInInventory(invArrayHolder[invPosHolder].recipieArray[invPos * 2])].quantity;
						}


						invTextRaw += "/" + invNumberToUse * invArrayHolder[invPosHolder].recipieArray[(invPos * 2) + 1];
					}

					if (invNumberToUse == 0) {
						invTextRaw = "CANCEL?"
					}

					if (performance.now() - invBlinkBefore >= invBlinkTime * 2 && invIsNumChosen == false) {
						invBlinkBefore = performance.now();
					}
				}
			}

			function drawCrafting() {
				drawItems(true);
			}	

			
			function drawItems(isCrafting) {
				if (isCrafting == undefined) {
					invArrayFocus = inventory;
				}
				else if (isCrafting == true && invArrayFocus.length == 0 && invIsNumChosen == false) {
					for (crf = 0; crf < itemTable.length; crf++) {
						if (itemTable[crf].isCraftable == true) {
							invArrayFocus.push(itemTable[crf]);
						}
					}										
				}				
				else if (isCrafting == true && invIsNumChosen == true && invArrayHolder.length == 0) {
					invArrayHolder = invArrayFocus;
					invArrayFocus = [];
					invPosHolder = invPos;

					for (mtl = 0; mtl < (invArrayHolder[invPosHolder].recipieArray.length / 2); mtl++) {
						invArrayFocus.push(itemTable[invArrayHolder[invPosHolder].recipieArray[mtl * 2]]);
					}

					invArrayFocus.push(itemTable[5]);

					invPos = 0;
					// invRecipiePos = 1; 
				}

				ctxMain.drawImage(invArrayFocus[invPos].sprite, 0, -pixelSize * 2);

				drawText(
					invArrayFocus[invPos].name, 
					textOnBlack, 
					"normal",
					ctxMain, 
					mainScreen, 
					0, 
					mainScreen.height - (2 * textHeight) - pixelSize, 
					6
				);

				if (listDoRun == false) {
					if (typeof(invArrayFocus[invPos].quantity) == "number") {
						invTextRaw = "*" + invArrayFocus[invPos].quantity;
					}
					else {
						invTextRaw = "";
					}

				}

				drawText(
					invTextRaw, 
					textOnWhite, 
					"center",
					ctxMain, 
					mainScreen, 
					0, 
					mainScreen.height - textHeight, 
					7
				);

				if (gameState == "textMenu") {
					textMenuDisplay(
						"USE", 
						isCrafting != true, 
						textMenuUse, 

						"CRAFT",
						isCrafting == true,
						textMenuCraft,

						"EXIT", 
						true, 
						textMenuExit
					);					
				}
				else {
					textAux = invArrayFocus[invPos].description;
				}

			}

			function findInInventory(itemIndex) {
				for (k = 0; k < inventory.length; k++) {
					if (inventory[k].name == itemTable[itemIndex].name) {
						return(k);
					}
				} 
		
				return(inventory.length);
			}

			function findInLootTable() {
				for (m = 0; m < inventory.length; m++) {
					if (inventory[invPos].name == itemTable[m].name) {
						return(m);
					}
				} 
		
				return(m);
			}

			function addToInventory(modifier, tableIndex) {
				invTarget = findInInventory(tableIndex);

				if (invTarget < inventory.length) {
					inventory[invTarget].quantity += modifier;
					
				}
				else if (invTarget == inventory.length) {
					inventory.splice(-1, 0, itemTable[tableIndex]);

					inventory[inventory.length - 2].quantity = modifier;
				}

			}

			function takeFromInventory(modifier, tableIndex) {
				if (arguments[1] == undefined) {
					invTarget = invPos;
				}
				else {
					invTarget = findInInventory(tableIndex);
				}

				if (modifier >= inventory[invPos].quantity) {
					inventory.splice(invTarget, 1);
				}
				else {
					inventory[invTarget].quantity -= modifier;
				}			
			}

			function useItem(num, tableIndex) {
				if (arguments[1] == undefined) {
					invTarget = invPos;
				}
				else {
					invTarget = findInInventory(tableIndex);
				}
	
				for (q = num; q > 0; q--) {			
					for (u = 0; u < inventory[invTarget].effectArray.length; u++) {
						inventory[invTarget].effectArray[u]();
					}
				}
			}

			function testAdd() {
				addToInventory(1,1);
			}


		/* Menu functions */


			function drawMenu() {
				ctxMain.drawImage(menuItems[menuPointer].sprite, 0, 0);
				textAux = menuItems[menuPointer].description;
				drawText(menuItems[menuPointer].title, textOnWhite, "normal", ctxMain, mainScreen, 0, mainScreen.height - textHeight, 1);

				menuAnchor = menuIndexStack[menuIndexStack.length - 1];
				menuMiddle = mainScreen.height - textHeight - pixelSize - squareIcon1.height;

				for (m = menuAnchor ; m != 0 && menuPips < 7; m = menuItems[m].referNext) {
					menuPips++;

					if (m == menuPointer) {
						menuCurrentPip = menuPips;
					}
				}

				menuPips++;

				if (m == menuPointer) {
					menuCurrentPip = menuPips;
				}

				menuPipTimeNow = performance.now();

				menuPips--;

				menuPipIndent = pixelSize + (squareIcon1.width * (3 - (Math.floor(menuPips / 2))));

				menuPips++;

				for (p = 1; p <= menuPips; p++) {
   					if (menuCurrentPip == p && menuPipTimeNow - menuPipTimeBefore >= menuPipRate) {
						menuPipImage = squareIcon2;
						
						if (menuPointer == 0) {
							menuPipImage = xSelectIcon;
						}				

						if (menuPipTimeNow - menuPipTimeBefore >= menuPipRate * 2) {
							menuPipTimeBefore = performance.now();
						}
					}
					else {
						menuPipImage = squareIcon1;

						if (p == menuPips) {
							menuPipImage = xUnselectIcon;
						}
					}
					
					ctxMain.drawImage(menuPipImage, menuPipIndent + ((p - 1) * squareIcon1.width), menuMiddle);
				}
				
				menuPips = 0;
			}
			
			function menuReturn() {
				if (menuIndexStack.length == 1) {
					gameState = "idle";
					idleState = "idle";

					menuIndexStack.pop();
				}
				else {					
					menuIndexStack.pop();
					menuPointer = menuIndexStack[menuIndexStack.length - 1];	
				}
			}

			function textMenuBlankSkip() {
				for (lbc = listPointer; (((lbc + 1) * 3) < listArray.length); lbc++) {
					if (listArray[((lbc + 1) * 3) + 1] == true || (lbc == 0 && listArray[(lbc * 3) + 1] == true && listStart == true)) {
						listPointer = lbc;

						break;
					}
				}

				if (((listPointer + 1) * 3) < listArray.length && listArray[((listPointer + 1) * 3) + 1] == true) {
					listPointer++;
				}
			}

			function textMenuCraft() {
				if (invIsNumChosen == false) {
					chooseNumToUse();
				}
				else if (invIsNumChosen == true) {	
					drawInvBlink();

					if (isTaskDone == true || (buttonProxyHeld == true && invPos == invArrayFocus.length - 1)) {
						invArrayFocus = invArrayHolder;
						invNumberToUse = 1;
						textMenuExit(true);
					}
				}
			}

			function textMenuDisplay() {
				listDisplayCount = 0;
				listArray = arguments;	

				if (listStart == true) {
					textMenuBlankSkip();	
					
					listStart = false;		
				}

				for (tm = 0; tm <= listArray.length; tm += 3) {
					if (listArray[1 + tm] == true) {
						if (listPointer == (tm / 3)) {
							listTextColor = textOnBlack;
						}
						else {
							listTextColor = textOnWhite;
						}

						drawText(
							listArray[tm], 
							listTextColor, 
							"normal",
							ctxAux, 
							auxScreen, 
							0, 
							textHeight * listDisplayCount, 
							8
						);
						
						listDisplayCount++;
					}
				}

				if (listDoRun == true) {
					listArray[((listPointer + 1) * 3) - 1]();
				}
			}

			function textMenuExit(resetPos) {
				gameState = gamePrev;

				listDoRun = false;
				listPointer = 0;

				invIsNumChosen = false;
				invArrayHolder = [];				
				invNumberToUse = 1;	
				if (resetPos == true) {
					invPos = invPosHolder;
				}	

				buttonProxyHeld = false;
			}

			function textMenuUse() {
				if (invArrayFocus[invPos].type == "resource") {
					if (chooseNumToUse() > 0) {
						if (chooseMonster() == true) {

							buttonBlocked = true;

							if (animationIsRecord == true) {
								
							}

							useItem(invNumberToUse);
							takeFromInventory(invNumberToUse);

							isTaskDone = true;
						}
					}
				}
				else if (invArrayFocus[invPos].type == "relic"){
					isTaskDone = true;
				}
				else if (invArrayFocus[invPos].type == "rig") {
					isTaskDone = true;
				}
				else if (invArrayFocus[invPos].type == "seed") {
					isTaskDone = true;
				}
				else if (invArrayFocus[invPos].type == "dev") {
					useItem(1);
					isTaskDone = true;
				}

				if (isTaskDone == true) {
					isTaskDone = false;
					buttonBlocked = false;

					textMenuExit();
				}
			}

			function updateMenu() {
				if (isButtonHeld == true) {
					if (menuItems[menuPointer].referNext == 0) {
						menuItems[0].referNext = menuIndexStack[menuIndexStack.length - 1];
					}
					if (gameState == "idle") {
						gameState = "menu";
						menuPointer = 1;
						menuIndexStack.push(menuPointer);
						animationQueue = [];
						animationIsRecord = true;
					}
					else if (gameState == "menu") {
						if (typeof(menuItems[menuPointer].referEnter) == "number") {
							menuPointer = menuItems[menuPointer].referEnter;

							menuIndexStack.push(menuPointer);
						}
						else if (typeof(menuItems[menuPointer].referEnter) == "function") {
							if(menuItems[menuPointer].referEnter == drawItems || 
							menuItems[menuPointer].referEnter == drawCrafting) {
								gameState = "inventory";
								
								invPos = 0;
							}
							else{						
								if (menuPointer != 0) {
									gameState = "subFunction";
								}
							}
								
							menuItems[menuPointer].referEnter(); 							
						}
					}
					else if (gameState == "subFunction") {
						gameState = "menu";
						subFunctionInitialized = false;

						animationQueue = [];
						animationIsRecord = true;
					}
					else if (gameState == "inventory") {
						if (invPos == (invArrayFocus.length - 1)) {
							invArrayFocus = [];
							invArrayHolder = [];
							gameState = "menu";						
						}
						else {
							gamePrev = gameState;
							gameState = "textMenu";
				
							listStart = true;
						}
					}		
					else if (gameState == "textMenu" && listDoRun == false) {
						listDoRun = true;
					}			
					else if (listDoRun == true) {
						if (buttonProxyHeld == false) {
							buttonProxyHeld = true;
						}
						else if (buttonProxyHeld == true) {
							buttonProxyHeld = false;
						}
					}

					buttonIgnoreClick = true;
					buttonHoldPending = true;
				}
				else if (buttonJustClicked == true) {
					if (gameState == "menu") {
						if (menuItems[menuPointer].referNext == 0 || menuPointer == 0) {
							menuItems[0].referNext = menuIndexStack[menuIndexStack.length - 1];
						}

						menuPointer = menuItems[menuPointer].referNext;

						if (menuItems[menuPointer].isDisplayed == false) {
							menuPointer = menuItems[menuPointer].referNext;
						}	
					}
					else if (gameState == "inventory" || invIsNumChosen == true) {
						if (invPos < invArrayFocus.length - 1 && invIsNumChosen == false) {
							invPos++;
						}
						else if (invArrayHolder.length > 0 && invPos < (invArrayHolder[invPosHolder].recipieArray.length / 2) && invIsNumChosen == true) {
							invPos++;
						}
					}
					else if (gameState == "textMenu" && listDoRun == false) {
						textMenuBlankSkip()
					}
				}
				else if (isButtonFlick == true) {
					if (gameState == "inventory" || invIsNumChosen == true) {
						if (invPos > 0) {
							invPos--;
						}
					}
					else if (gameState == "textMenu" && listDoRun == false) {
						for (lbc = listPointer; (lbc > 0); lbc--) {
							if (listArray[((lbc - 1) * 3) + 1] == true) {
								listPointer = lbc;

								break;
							}
						}

						if (listPointer > 0 && listArray[((lbc - 1) * 3) + 1] == true) {
							listPointer--;
						}
					}
				}
			}
			

		/* Minigame functions */
			
			function strobeDance() {

			}


			function strobeGame() {
				if (subFunctionInitialized == false) {
					strobeRate = Infinity;
					strobeDeltaClick = 0;
					strobeFirstClick = true;
					invertOn = false;

					subFunctionInitialized = true;
				}

				if (animationIsRecord == true && animationQueue.length == 0) {
					animationQueue.push(
						new AnimationObject(
							image2,
							0,	  /* X coord */
							0,	  /* Y coord  */
							ctxMain,  /*  context/cxt  */
							mainScreen,  /* screen */
							buttonJustClicked,   /* miscData */

							invertDraw,  /* function  */
							0,		   /* delay  */
							2,	  /* queue pos  */
							[false, Infinity],	/* do When  */
							[0, Infinity],		 /* do Every */
							[],	   /*  do Chain */
							-1,	 /* do Once  */

							invertColor,
							0,	  /* delay  */
							1,	  /* queue pos  */
							[false, Infinity],	/* do When  */
							["strobeRate", Infinity],   /* do Every */
							[],	 /*  do Chain */
							-1,	/* do Once  */

							strobeDance,  /* function  */
							0,		   /* delay  */
							0,	  /* queue pos  */
							[false, Infinity],	/* do When  */
							["strobeRate", Infinity],		 /* do Every */
							[],	   /*  do Chain */
							-1,	 /* do Once  */

							regDraw,	/* function  */
							0,		   /* delay  */
							0,	  /* queue pos  */
							[false, Infinity],	/* do When  */
							[0, Infinity],		 /* do Every */
							[],	   /*  do Chain */
							-1	 /* do Once  */ 



						)
					);
				}

				if (strobeFirstClick == true) {
					textAux = "FIRST CLICK! HOLD TO EXIT!";
				}
				else if (strobeFirstClick == false && strobeDeltaClick < timeUnpressed) {					
					strobeDeltaClick = timeUnpressed;					
				}

				if (strobeFirstClick == true && buttonJustClicked == true) {
					strobeFirstClick = false;

					textAux = "SECOND CLICK! HOLD TO EXIT!";
				}
				else if (strobeFirstClick == false && buttonJustClicked == true) {
					strobeRate = strobeDeltaClick;
					strobeFirstClick = true;
					strobeDeltaClick = 0;
				}
			}


		/* Main screen functions */


			function drawIdle() {
				if (animationIsRecord == true) {
					animationQueue.push(
						new AnimationObject(
							currentIdle,
							0,	  /* X coord */
							0,	  /* Y coord  */
							ctxMain,  /*  context/cxt  */
							mainScreen,  /* screen */
							buttonJustClicked,   /* miscData */

							updateIdle,   /* function  */
							0,	  /* delay  */
							1,	  /* queue pos  */
							[false, Infinity],	/* do When  */
							[1000, Infinity],   /* do Every */
							[],	 /*  do Chain */
							-1,	/* do Once  */

							flipHozDraw,	/* function  */
							0,		   /* delay  */
							2,	  /* queue pos  */
							["flipImage == true && idleState != \"walk\"", Infinity],	/* do When  */
							[-1, Infinity],		/* do Every */
							[],	   /*  do Chain */
							-1,	  /* do Once  */
													
							updateWalk,	/* function  */
							0,		   /* delay  */
							1,	  /* queue pos  */
							["buttonJustClicked", Infinity],
							[1000, Infinity],		 /* do Every */
							[],	   /*  do Chain */
							-1,	  /* do Once  */

							regDraw,	/* function  */
							0,		   /* delay  */
							2,	  /* queue pos  */
							[false, Infinity],	/* do When  */
							[0, Infinity],		 /* do Every */
							[],	   /*  do Chain */
							-1	 /* do Once  */							


						)
					);							
				}
			}

			function updateIdle() {
				if (animationQueue[a].sprite == image2) {
					animationQueue[a].sprite = image4;
				}
				else if (animationQueue[a].sprite == image4) {
					animationQueue[a].sprite = image2;
				}
					
				if (Math.random() > 0.5) {
					flipImage = true;
				}
				else {
					flipImage = false;
				}	
			} 

			function updateWalk() {
				if (idleState == "idle" && buttonJustClicked == true && coinsSubtracting <= 0) { 

					idleState = "walk";
					animationQueue[a].sprite = walk1;
					flipImage = false;				
				}

				if (idleState == "walk" && timeUnpressed <= timeForDrop && coinsSubtracting <= 0 && gameState == "idle") {
					if (animationQueue[a].sprite == walk1) {
						animationQueue[a].sprite = walk2;
					}
					else if (animationQueue[a].sprite == walk2) {
						animationQueue[a].sprite = walk1;
					}
				}
				else if (idleState == "walk") {
					idleState = "idle";
					animationQueue[a].sprite = image2;
				}				
			} 


		/* Aux screen functions */

			function drawAux() {
				ctxAux.clearRect(0, 0, auxScreen.width, auxScreen.height);

				drawBackground(ctxAux);
				drawText(textAux, textOnWhite, "normal", ctxAux, auxScreen, 0, 0, 2);
				drawGrid(ctxAux);

				/* "THE QUICK, BROWN FOX JUMPED OVER THE LAZY DOG." */
			}

			function drawCoins() {
				drawText("COINS", textOnBlack, "center", ctxAux, auxScreen, 0, 0, 3);
				drawText(coinsCurrent.toString(), textOnWhite, "center", ctxAux, auxScreen, 0, textHeight + pixelSize, 4);

				if (coinsSubtracting > 0) {
					drawText(coinsSubtracting.toString(), textOnWhite, "normal", ctxAux, auxScreen, 0, textHeight * 2 + pixelSize, 5);
				}

			}


			function updateCoins() {
				if (coinsSubtracting >= 0) {
					coinsSubtracting = coinsToSubtract;
					coinsSubtractingTimeBefore = performance.now();
					
					if (coinsToSubtract >= 100) {
						coinsSubtractingIncrement = 5;
					}
					if (coinsToSubtract >= 500) {
						coinsSubtractingIncrement = 25;
					}
					else {
						coinsSubtractingIncrement = 1;
					}
				}

				if (buttonJustClicked == true && coinsSubtracting <= 0) {
					coinsCurrent += coinsClickPower;
				}

				coinsPassiveCounterNow = performance.now();

				if (coinsPassiveCounterNow - coinsPassiveCounterBefore >= coinsPassiveClick && coinsCurrent > 0 && coinsSubtracting <= 0 && coinsPassiveActive == true) {
					coinsCurrent += coinsPassivePower;

					coinsPassiveCounterBefore = performance.now();
				}

				coinsAddingTimeNow = performance.now();

				if (coinsSubtracting > 0 && coinsSubtratcingTimeNow - coinsSubtractingTimeBefore >= coinsSubtractingUpdate) {
					buttonBlocked = true;

					coinsSubtracting += coinsSubtractingIncrement;
					coinsCurrent -= coinsSubtractingIncrement;

					coinsSubtractingTimeBefore = performance.now();
				}
				else if (coinsSubtracting <= 0) {
					buttonBlocked = false;
				}
			}

		/* Button functions */	


			function drawButton() {
				ctxButton.clearRect(0,0, theButtonScreen.width, theButtonScreen.height);

				drawBackground(ctxButton);
				ctxButton.drawImage(buttonImage, 0, 0);
				drawGrid(ctxButton);
			}

			function mouseDownHandler() {
				isButtonClick = true;

				timeStartClick, timeLastClick = performance.now();	
				timeUnpressed = 0;
			}

			function mouseEnterHandler() {
				isButtonHover = true;
			}

			function mouseLeaveHandler() {
				if (isButtonClick == true) {
					isButtonFlick = true;
				}

				isButtonHover = false;
				isButtonClick = false;
			}

			function mouseUpHandler() {
				if (isButtonClick == true && isButtonHover == true && buttonIgnoreClick == false) {
					buttonJustClicked = true;
				}		

				if (isButtonHover == true) {
					timeStartClick = 0; 
				}

				isButtonClick = false;
				isButtonHeld = false;				
				buttonHoldPending = false;
				buttonIgnoreClick = false;
			}

			function buttonUpdate() {
				if (isButtonClick == true && buttonBlocked == false) {
					buttonImage = buttonClick;
					
					if (isButtonHover == false) {
						buttonImage = buttonIdle;						
					}

					timeHeldDown = performance.now() - timeLastClick;

					if (timeHeldDown >= timeForHold && buttonHoldPending == false && isButtonHover == true) {
						isButtonHeld = true; 
					} 
					else if (buttonHoldPending == true) {
						isButtonHeld = false;
					}

				}
				else if (isButtonHover == true) {
					buttonImage = buttonHover;			
				}
				else {
					buttonImage = buttonIdle;
				}
				
				buttonJustClicked = false;
				isButtonFlick = false;

				timeUnpressed = performance.now() - timeLastClick;
			}
		

	
 
		</script>
	</body>
</html>


